/*
Deployment script for ponalab_tracking_staging_db

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "ponalab_tracking_staging_db"
:setvar DefaultFilePrefix "ponalab_tracking_staging_db"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER2014\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER2014\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
/*
The type for column Contact # in table [dbo].[CustomerMaster] is currently  NVARCHAR (255) NULL but is being changed to  FLOAT (53) NULL. Data loss could occur.

The type for column Staff ID in table [dbo].[CustomerMaster] is currently  NVARCHAR (255) NULL but is being changed to  FLOAT (53) NULL. Data loss could occur.
*/

IF EXISTS (select top 1 1 from [dbo].[CustomerMaster])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The type for column KG/LT in table [dbo].[MaterialMaster] is currently  NVARCHAR (255) NULL but is being changed to  FLOAT (53) NULL. Data loss could occur.

The type for column No of Units in table [dbo].[MaterialMaster] is currently  NVARCHAR (255) NULL but is being changed to  FLOAT (53) NULL. Data loss could occur.
*/

IF EXISTS (select top 1 1 from [dbo].[MaterialMaster])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
PRINT N'Dropping unnamed constraint on [dbo].[Order]...';


GO
ALTER TABLE [dbo].[Order] DROP CONSTRAINT [DF__Order__ItemCount__27F8EE98];


GO
PRINT N'Dropping unnamed constraint on [dbo].[Order]...';


GO
ALTER TABLE [dbo].[Order] DROP CONSTRAINT [DF__Order__IsApprove__28ED12D1];


GO
PRINT N'Dropping unnamed constraint on [dbo].[Order]...';


GO
ALTER TABLE [dbo].[Order] DROP CONSTRAINT [DF__Order__ApproveDa__29E1370A];


GO
PRINT N'Dropping unnamed constraint on [dbo].[Order]...';


GO
ALTER TABLE [dbo].[Order] DROP CONSTRAINT [DF__Order__ApproveAm__2AD55B43];


GO
PRINT N'Dropping unnamed constraint on [dbo].[Order]...';


GO
ALTER TABLE [dbo].[Order] DROP CONSTRAINT [DF__Order__ApprovedB__2BC97F7C];


GO
PRINT N'Dropping unnamed constraint on [dbo].[Order]...';


GO
ALTER TABLE [dbo].[Order] DROP CONSTRAINT [DF__Order__DateCreat__2CBDA3B5];


GO
PRINT N'Dropping unnamed constraint on [dbo].[Order]...';


GO
ALTER TABLE [dbo].[Order] DROP CONSTRAINT [DF__Order__DateUpdat__2DB1C7EE];


GO
PRINT N'Dropping unnamed constraint on [dbo].[SqliteAction]...';


GO
ALTER TABLE [dbo].[SqliteAction] DROP CONSTRAINT [DF__tmp_ms_xx__Activ__47A6A41B];


GO
PRINT N'Dropping unnamed constraint on [dbo].[SqliteAction]...';


GO
ALTER TABLE [dbo].[SqliteAction] DROP CONSTRAINT [DF__tmp_ms_xx__Image__489AC854];


GO
PRINT N'Dropping unnamed constraint on [dbo].[SqliteAction]...';


GO
ALTER TABLE [dbo].[SqliteAction] DROP CONSTRAINT [DF__tmp_ms_xx__IsPos__4A8310C6];


GO
PRINT N'Dropping unnamed constraint on [dbo].[SqliteAction]...';


GO
ALTER TABLE [dbo].[SqliteAction] DROP CONSTRAINT [DF__tmp_ms_xx__IsPro__498EEC8D];


GO
PRINT N'Dropping unnamed constraint on [dbo].[SqliteAction]...';


GO
ALTER TABLE [dbo].[SqliteAction] DROP CONSTRAINT [DF__tmp_ms_xx__DateU__4E53A1AA];


GO
PRINT N'Dropping unnamed constraint on [dbo].[SqliteAction]...';


GO
ALTER TABLE [dbo].[SqliteAction] DROP CONSTRAINT [DF__tmp_ms_xx__DateC__4D5F7D71];


GO
PRINT N'Dropping unnamed constraint on [dbo].[SqliteAction]...';


GO
ALTER TABLE [dbo].[SqliteAction] DROP CONSTRAINT [DF__tmp_ms_xx__Activ__4C6B5938];


GO
PRINT N'Dropping unnamed constraint on [dbo].[SqliteAction]...';


GO
ALTER TABLE [dbo].[SqliteAction] DROP CONSTRAINT [DF__tmp_ms_xx__Track__4B7734FF];


GO
PRINT N'Dropping unnamed constraint on [dbo].[Order]...';


GO
ALTER TABLE [dbo].[Order] DROP CONSTRAINT [FK__Order__EmployeeI__4830B400];


GO
PRINT N'Dropping unnamed constraint on [dbo].[Order]...';


GO
ALTER TABLE [dbo].[Order] DROP CONSTRAINT [FK__Order__DayId__6CA31EA0];


GO
PRINT N'Dropping unnamed constraint on [dbo].[OrderItem]...';


GO
ALTER TABLE [dbo].[OrderItem] DROP CONSTRAINT [FK__OrderItem__Order__6D9742D9];


GO
PRINT N'Dropping unnamed constraint on [dbo].[SqliteActionImage]...';


GO
ALTER TABLE [dbo].[SqliteActionImage] DROP CONSTRAINT [FK__SqliteAct__Sqlit__753864A1];


GO
PRINT N'Dropping unnamed constraint on [dbo].[SqliteAction]...';


GO
ALTER TABLE [dbo].[SqliteAction] DROP CONSTRAINT [FK__SqliteAct__Batch__6319B466];


GO
PRINT N'Altering [dbo].[CustomerMaster]...';


GO
ALTER TABLE [dbo].[CustomerMaster] ALTER COLUMN [Contact #] FLOAT (53) NULL;

ALTER TABLE [dbo].[CustomerMaster] ALTER COLUMN [Staff ID] FLOAT (53) NULL;


GO
PRINT N'Altering [dbo].[EmployeeDay]...';


GO
ALTER TABLE [dbo].[EmployeeDay]
    ADD [TotalOrderAmount]   DECIMAL (19, 2) DEFAULT 0 NOT NULL,
        [TotalPaymentAmount] DECIMAL (19, 2) DEFAULT 0 NOT NULL,
        [TotalReturnAmount]  DECIMAL (19, 2) DEFAULT 0 NOT NULL,
        [TotalExpenseAmount] DECIMAL (19, 2) DEFAULT 0 NOT NULL,
        [CurrentLatitude]    DECIMAL (19, 9) DEFAULT 0 NOT NULL,
        [CurrentLongitude]   DECIMAL (19, 9) DEFAULT 0 NOT NULL,
        [HasMultipleStarts]  BIT             DEFAULT 0 NOT NULL,
        [HQCode]             NVARCHAR (10)   DEFAULT '' NOT NULL,
        [AreaCode]           NVARCHAR (10)   DEFAULT '' NOT NULL,
        [PhoneModel]         NVARCHAR (100)  NULL,
        [PhoneOS]            NVARCHAR (10)   NULL,
        [AppVersion]         NVARCHAR (10)   NULL;


GO
PRINT N'Altering [dbo].[MaterialMaster]...';


GO
ALTER TABLE [dbo].[MaterialMaster] ALTER COLUMN [KG/LT] FLOAT (53) NULL;

ALTER TABLE [dbo].[MaterialMaster] ALTER COLUMN [No of Units] FLOAT (53) NULL;


GO
PRINT N'Starting rebuilding table [dbo].[Order]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_Order] (
    [Id]                 BIGINT          IDENTITY (1, 1) NOT NULL,
    [EmployeeId]         BIGINT          NOT NULL,
    [DayId]              BIGINT          NOT NULL,
    [CustomerCode]       NVARCHAR (50)   NOT NULL,
    [OrderType]          NVARCHAR (10)   NOT NULL,
    [OrderDate]          DATETIME2 (7)   NOT NULL,
    [TotalAmount]        DECIMAL (19, 2) NOT NULL,
    [ItemCount]          BIGINT          DEFAULT 0 NOT NULL,
    [RevisedTotalAmount] DECIMAL (19, 2) DEFAULT 0 NOT NULL,
    [IsApproved]         BIT             DEFAULT 0 NOT NULL,
    [ApproveDate]        DATETIME2 (7)   DEFAULT SYSUTCDATETIME() NOT NULL,
    [ApproveRef]         NVARCHAR (255)  NULL,
    [ApproveNotes]       NVARCHAR (2048) NULL,
    [ApproveAmount]      DECIMAL (19, 2) DEFAULT 0 NOT NULL,
    [ApprovedBy]         NVARCHAR (50)   DEFAULT '' NOT NULL,
    [DateCreated]        DATETIME2 (7)   DEFAULT SYSUTCDATETIME() NOT NULL,
    [DateUpdated]        DATETIME2 (7)   DEFAULT SYSUTCDATETIME() NOT NULL,
    [SqliteOrderId]      BIGINT          NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[Order])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_Order] ON;
        INSERT INTO [dbo].[tmp_ms_xx_Order] ([Id], [EmployeeId], [DayId], [CustomerCode], [OrderType], [OrderDate], [TotalAmount], [ItemCount], [IsApproved], [ApproveDate], [ApproveRef], [ApproveNotes], [ApproveAmount], [ApprovedBy], [DateCreated], [DateUpdated], [SqliteOrderId])
        SELECT   [Id],
                 [EmployeeId],
                 [DayId],
                 [CustomerCode],
                 [OrderType],
                 [OrderDate],
                 [TotalAmount],
                 [ItemCount],
                 [IsApproved],
                 [ApproveDate],
                 [ApproveRef],
                 [ApproveNotes],
                 [ApproveAmount],
                 [ApprovedBy],
                 [DateCreated],
                 [DateUpdated],
                 [SqliteOrderId]
        FROM     [dbo].[Order]
        ORDER BY [Id] ASC;
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_Order] OFF;
    END

DROP TABLE [dbo].[Order];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_Order]', N'Order';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Altering [dbo].[OrderItem]...';


GO
ALTER TABLE [dbo].[OrderItem]
    ADD [RevisedUnitQuantity] INT             DEFAULT 0 NOT NULL,
        [RevisedAmount]       DECIMAL (19, 2) DEFAULT 0 NOT NULL,
        [DateUpdated]         DATETIME2 (7)   NULL,
        [UpdatedBy]           NVARCHAR (50)   NULL;


GO
PRINT N'Starting rebuilding table [dbo].[SqliteAction]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_SqliteAction] (
    [Id]                   BIGINT          IDENTITY (1, 1) NOT NULL,
    [SqliteTableId]        BIGINT          NOT NULL,
    [BatchId]              BIGINT          NOT NULL,
    [EmployeeId]           BIGINT          NOT NULL,
    [At]                   DATETIME2 (7)   NOT NULL,
    [Name]                 NVARCHAR (20)   NOT NULL,
    [ActivityTrackingType] INT             DEFAULT 0 NOT NULL,
    [Latitude]             DECIMAL (19, 9) NOT NULL,
    [Longitude]            DECIMAL (19, 9) NOT NULL,
    [MNC]                  BIGINT          NOT NULL,
    [MCC]                  BIGINT          NOT NULL,
    [LAC]                  BIGINT          NOT NULL,
    [CellId]               BIGINT          NOT NULL,
    [ClientName]           NVARCHAR (50)   NOT NULL,
    [ClientPhone]          NVARCHAR (20)   NOT NULL,
    [ClientType]           NVARCHAR (50)   NOT NULL,
    [ActivityType]         NVARCHAR (50)   NOT NULL,
    [Comments]             NVARCHAR (2048) NOT NULL,
    [ImageCount]           INT             DEFAULT 0 NOT NULL,
    [IsProcessed]          BIT             DEFAULT 0 NOT NULL,
    [IsPostedSuccessfully] BIT             DEFAULT 0 NOT NULL,
    [TrackingId]           BIGINT          DEFAULT 0 NOT NULL,
    [ActivityId]           BIGINT          DEFAULT 0 NOT NULL,
    [PhoneModel]           NVARCHAR (100)  NULL,
    [PhoneOS]              NVARCHAR (10)   NULL,
    [AppVersion]           NVARCHAR (10)   NULL,
    [DateCreated]          DATETIME2 (7)   DEFAULT SYSUTCDATETIME() NOT NULL,
    [DateUpdated]          DATETIME2 (7)   DEFAULT SYSUTCDATETIME() NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[SqliteAction])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_SqliteAction] ON;
        INSERT INTO [dbo].[tmp_ms_xx_SqliteAction] ([Id], [SqliteTableId], [BatchId], [EmployeeId], [At], [Name], [ActivityTrackingType], [Latitude], [Longitude], [MNC], [MCC], [LAC], [CellId], [ClientName], [ClientPhone], [ClientType], [ActivityType], [Comments], [ImageCount], [IsProcessed], [IsPostedSuccessfully], [TrackingId], [ActivityId], [DateCreated], [DateUpdated])
        SELECT   [Id],
                 [SqliteTableId],
                 [BatchId],
                 [EmployeeId],
                 [At],
                 [Name],
                 [ActivityTrackingType],
                 [Latitude],
                 [Longitude],
                 [MNC],
                 [MCC],
                 [LAC],
                 [CellId],
                 [ClientName],
                 [ClientPhone],
                 [ClientType],
                 [ActivityType],
                 [Comments],
                 [ImageCount],
                 [IsProcessed],
                 [IsPostedSuccessfully],
                 [TrackingId],
                 [ActivityId],
                 [DateCreated],
                 [DateUpdated]
        FROM     [dbo].[SqliteAction]
        ORDER BY [Id] ASC;
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_SqliteAction] OFF;
    END

DROP TABLE [dbo].[SqliteAction];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_SqliteAction]', N'SqliteAction';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Creating [dbo].[SqliteAction].[IX_SqliteAction_IsProcessed]...';


GO
CREATE NONCLUSTERED INDEX [IX_SqliteAction_IsProcessed]
    ON [dbo].[SqliteAction]([IsProcessed] ASC);


GO
PRINT N'Creating [dbo].[SqliteAction].[IX_SqliteAction_EmpIdActionName]...';


GO
CREATE NONCLUSTERED INDEX [IX_SqliteAction_EmpIdActionName]
    ON [dbo].[SqliteAction]([EmployeeId] ASC, [ActivityTrackingType] ASC, [At] ASC);


GO
PRINT N'Creating [dbo].[AppVersion]...';


GO
CREATE TABLE [dbo].[AppVersion] (
    [Id]            INT           IDENTITY (1, 1) NOT NULL,
    [Version]       NVARCHAR (10) NOT NULL,
    [EffectiveDate] DATE          NOT NULL,
    [ExpiryDate]    DATE          NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[ExecAppImei]...';


GO
CREATE TABLE [dbo].[ExecAppImei] (
    [Id]            INT           IDENTITY (1, 1) NOT NULL,
    [IMEINumber]    NVARCHAR (50) NOT NULL,
    [EffectiveDate] DATE          NOT NULL,
    [ExpiryDate]    DATE          NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating unnamed constraint on [dbo].[Order]...';


GO
ALTER TABLE [dbo].[Order] WITH NOCHECK
    ADD FOREIGN KEY ([EmployeeId]) REFERENCES [dbo].[TenantEmployee] ([Id]);


GO
PRINT N'Creating unnamed constraint on [dbo].[Order]...';


GO
ALTER TABLE [dbo].[Order] WITH NOCHECK
    ADD FOREIGN KEY ([DayId]) REFERENCES [dbo].[Day] ([Id]);


GO
PRINT N'Creating unnamed constraint on [dbo].[OrderItem]...';


GO
ALTER TABLE [dbo].[OrderItem] WITH NOCHECK
    ADD FOREIGN KEY ([OrderId]) REFERENCES [dbo].[Order] ([Id]);


GO
PRINT N'Creating unnamed constraint on [dbo].[SqliteActionImage]...';


GO
ALTER TABLE [dbo].[SqliteActionImage] WITH NOCHECK
    ADD FOREIGN KEY ([SqliteActionId]) REFERENCES [dbo].[SqliteAction] ([Id]);


GO
PRINT N'Creating unnamed constraint on [dbo].[SqliteAction]...';


GO
ALTER TABLE [dbo].[SqliteAction] WITH NOCHECK
    ADD FOREIGN KEY ([BatchId]) REFERENCES [dbo].[SqliteActionBatch] ([Id]);


GO
PRINT N'Altering [dbo].[TransformDataFeed]...';


GO
ALTER PROCEDURE [dbo].[TransformDataFeed]
	@tenantId BIGINT
AS
BEGIN
		-- Stored procedure to put data from SAP data feed (tables)
		-- to local tables

		-- Step 1: Not defined.
		-- Input Tables
		-- CustomerMaster
		-- MaterialMaster
		-- EmployeeMaster
		-- PriceList

		-- Nov 17 2017 - don't delete existing data from Sales Person table
		-- From Employee Master, take new records and put them in SalesPerson table.

		-- Step 2: Wipe out existing data
		DELETE FROM dbo.ProductPrice
		DELETE FROM dbo.Product;
		DELETE FROM dbo.ProductGroup;
		DELETE FROM dbo.Customer;
		--DELETE FROM dbo.SalesPerson;

		-- Step 3: Insert data in Product Group and Product table
		INSERT INTO dbo.ProductGroup
		(GroupName)
		SELECT DISTINCT ltrim(rtrim([Product Group])) FROM dbo.MaterialMaster
		WHERE [Product Group] IS NOT NULL

		-- Step 4: Insert data in Product table
		;WITH materialCTE(productCode, ProductGroup, Name, UOM, BrandName, ShelfLifeInMonths, IsActive, RN)
		AS
		(
			SELECT rtrim(ltrim(mm.Material)),
			ltrim(rtrim([Product Group])),
			ISNULL(mm.[Description], ''), 
			ISNULL(mm.UOM,''), 
			ISNULL(mm.[Brand Name],''),
			ISNULL(mm.[Shelf Life in months], 0),
			Case when mm.[Status] = 'ACTIVE' THEN 1 ELSE 0 END,
			Row_Number() OVER (Partition By rtrim(ltrim(mm.Material)) ORDER BY rtrim(ltrim(mm.Material)) )
			FROM dbo.MaterialMaster mm
			WHERE [Product Group] IS NOT NULL
		)
		INSERT INTO dbo.Product
		(GroupId, ProductCode, Name, UOM, BrandName, ShelfLifeInMonths, IsActive, MRP)
		SELECT pg.Id, cte.productCode, cte.Name, cte.UOM, cte.BrandName, cte.ShelfLifeInMonths, CTE.IsActive, 0
		 FROM materialCTE cte
		INNER JOIN dbo.ProductGroup pg on cte.ProductGroup = pg.GroupName
		AND cte.RN = 1
	
		-- Step 4: Insert data in ProductPrice table
		INSERT INTO dbo.ProductPrice
		(ProductId, AreaCode, Stock, [MRP], DistPrice, PDISTPrice, DEALERPrice)
		SELECT p.Id, 
		LEFT(ISNULL(pl.AO, ''),10),
		ISNULL(pl.Stock, 0),
		ISNULL(pl.MRP,0),
		ISNULL(pl.[Dist Rate],0), 
		ISNULL(pl.[PD'S Rate],0),
		ISNULL(pl.[Dealers Rate],0)
		FROM dbo.PriceList pl
		INNER JOIN dbo.Product p ON ltrim(rtrim(pl.[PRODUCT CODE])) = p.ProductCode
		AND pl.[PRODUCT CODE] IS NOT NULL

		-- Step 5: Insert data in SalesPerson table
		INSERT INTO dbo.SalesPerson
		([StaffCode], [Name], [Phone], [HQCode], [IsActive])
		SELECT  ltrim(STR(ISNULL([Staff Code],0),10,0)),
		ISNULL(ltrim(rtrim(em.Name)),''),
		ltrim(Str(IsNULL(em.[Phone], 0), 50, 0)),
		ltrim(rtrim(ISNULL([Head Quarter], ''))),
		Case when ltrim(rtrim([Action])) = 'ACTIVE' THEN 1 ELSE 0 END
		FROM dbo.EmployeeMaster em
		LEFT JOIN dbo.SalesPerson sp ON [Staff Code] IS NOT NULL
				AND ltrim(STR(ISNULL(em.[Staff Code],0),10,0)) = sp.StaffCode
		WHERE sp.StaffCode IS NULL

		-- Step 6: Insert data in Customer table
		INSERT INTO [dbo].[Customer]
		([CustomerCode], [Name], [Type], [CreditLimit], 
		[Outstanding], [LongOutstanding], [District], [State], [Branch], [Pincode], [HQCode], [ContactNumber],
		[Target], [Sales], [Payment])
		SELECT 
		left(cm.[Customer Code], 20),
		left(cm.[Customer Name],50), 
		cm.[Type], 
		ISNULL(cm.[Credit Limit],0),
		ISNULL([Total Outstanding], 0),
		ISNULL([Total Overdue >90], 0),
		left(cm.[District Name],50),
		left(cm.[State Name],50),
		left(cm.[Branch Name],50),
		left(cm.Pincode,10),
		left(ISNULL([HQ Code], ''),10),
		ltrim(Str(IsNULL([Contact #], 0), 50, 0)),
		ISNULL([Expected Business], 0), -- Target
		ISNULL([Sales],0),  -- Sales
		ISNULL([Collection], 0) -- Payment
		FROM dbo.CustomerMaster cm
		WHERE cm.[Type] IS NOT NULL

		INSERT INTO dbo.ErrorLog
		(Process, LogText)
		SELECT 'SP:TransformDataFeed', 'Success'
END
GO
PRINT N'Altering [dbo].[AddTrackingData]...';


GO
ALTER PROCEDURE [dbo].[AddTrackingData]
	@employeeDayId BIGINT,
	@trackingDateTime DateTime2,
	@latitude Decimal(19,9),
	@longitude Decimal(19,9),
	@activityId BIGINT,
	@isMilestone BIT,  -- 1 if we want to log this request irrespective of the fact that it is sent too soon
	@isStartOfDay BIT,
	@isEndOfDay BIT,
	@trackingId BIGINT OUTPUT
AS
BEGIN
   -- Records tracking activity
   -- distanceInMeters that is passed from Mobile Device is not saved in db.
    SET @trackingId = 0
	-- check if a record already exist in Employee Day table
	-- At end of the day, we do need to log a tracking entry as MileStone flag set to 1 - hence the OR condition here;
	IF EXISTS(SELECT 1 FROM dbo.EmployeeDay WHERE Id = @employeeDayId AND (EndTime is null OR @isMilestone = 1))
	BEGIN
	    -- Find out Begin coordinates from last record
		DECLARE @beginLatitude DECIMAL(19,9) = 0
		DECLARE @beginLongitude DECIMAL(19,9) = 0
		DECLARE @chainedTrackingId BIGINT = 0
		DECLARE @lastTrackingDateTime DATETIME2

		IF @isStartOfDay = 1
		BEGIN
			SET @chainedTrackingId = NULL
		END
		ELSE IF @isMilestone = 1
		BEGIN
		    -- for milestone recordings - look for previous milestone entries or first entry
			SELECT @chainedTrackingId = MAX(ID)
				FROM dbo.Tracking WITH (NOLOCK)
				WHERE EmployeeDayId = @employeeDayId
				AND IsMilestone = 1
		END
		ELSE
		BEGIN
			SELECT @chainedTrackingId = MAX(ID)
				FROM dbo.Tracking WITH (NOLOCK)
				WHERE EmployeeDayId = @employeeDayId
		END
 
		------------------

		SELECT @beginLatitude = EndGpsLatitude,
		       @beginLongitude = EndGpsLongitude,
			   @lastTrackingDateTime = [At]
		FROM dbo.tracking WITH (NOLOCK)
		WHERE Id = ISNULL(@chainedTrackingId,0)

		-- if tracking request is coming too soon - from configured time
		-- don't log the tracking request
		DECLARE @logCurrentTrackingRequest BIT = 0;
		IF @isMilestone = 1 OR ISNULL(@chainedTrackingId,0) = 0
		BEGIN
		    -- must log milestone entries;
			-- first tracking request for day - log it;
			SET @logCurrentTrackingRequest = 1
		END
		ELSE
		IF @beginLatitude = @latitude AND @beginLongitude = @longitude
		BEGIN
			SET @logCurrentTrackingRequest = 0
		END
		ELSE
		BEGIN
			-- find out expected delay
			DECLARE @TimeIntervalInMillisecondsForTracking BIGINT
			SELECT @TimeIntervalInMillisecondsForTracking = te.TimeIntervalInMillisecondsForTracking
			FROM dbo.TenantEmployee te
			INNER JOIN dbo.EmployeeDay ed on te.Id = ed.TenantEmployeeId
			AND ed.Id = @employeeDayId

			-- add time to last tracking record time
			IF DATEDIFF(ms, @lastTrackingDateTime, @trackingDateTime) >= @TimeIntervalInMillisecondsForTracking
			BEGIN
				SET @logCurrentTrackingRequest = 1
			END
		END
		
		------------------------------

		IF @logCurrentTrackingRequest = 1
		BEGIN
			-- Create new record in Tracking table
			INSERT into dbo.Tracking
			(ChainedTrackingId, EmployeeDayId, [At], BeginGPSLatitude, BeginGPSLongitude, 
			EndGPSLatitude, EndGPSLongitude, BeginLocationName, EndLocationName, BingMapsDistanceInMeters, 
			GoogleMapsDistanceInMeters, LinearDistanceInMeters,
			DistanceCalculated, LockTimestamp, 
			ActivityId, IsMilestone, IsStartOfDay, IsEndOfDay)
			VALUES
			(@chainedTrackingId, @employeeDayId, @trackingDateTime, @beginLatitude, @beginLongitude,
			 @latitude, @longitude, NULL, NULL, 0,
			 0, 0,
			 --@isStartOfDay, Null,
			 0, Null,
			 -- if it is start of day request, then we mark it as calculated
			 -- for start of day also, leave distance calculated as 0 - so we can get location name for reports
			 @activityId, @isMilestone,
			 @isStartOfDay,
			 @isEndOfDay)

			SET @trackingId = SCOPE_IDENTITY()

             -- update most recent location in EmployeeDay table as well
			 UPDATE dbo.EmployeeDay
			 SET CurrentLatitude = @latitude,
			 CurrentLongitude = @longitude
			 WHERE Id = @employeeDayId
		END
		ELSE
		BEGIN
			SET @trackingId = -2
		END
	END
END
GO
PRINT N'Altering [dbo].[ProcessSqliteExpenseData]...';


GO
ALTER PROCEDURE [dbo].[ProcessSqliteExpenseData]
	@batchId BIGINT
AS
BEGIN

	-- if batch is already processed - return	
	IF NOT EXISTS(SELECT 1 FROM dbo.SqliteActionBatch 
			WHERE Id = @batchId AND ExpenseLineSavedCount > 0
			AND BatchProcessed = 0)
	BEGIN
		RETURN;
	END

	DECLARE @NewExpenses TABLE
	(EmployeeId BIGINT,
	 DayId BIGINT,
	 TotalAmount DECIMAL(19,2)
	)

	-- First create Expense Record

	-- Fetch expense Date
	DECLARE @expenseDate DATETIME2
	SELECT @expenseDate = ExpenseDate
	FROM dbo.SqliteActionBatch 
	WHERE Id = @batchId AND ExpenseLineSavedCount > 0

	IF @expenseDate IS NOT NULL
	BEGIN
	   -- Create Day Record if not already there
	   DECLARE @dayId BIGINT
	   DECLARE @dt DATE = CAST(@expenseDate AS [Date])

		IF EXISTS(SELECT 1 FROM dbo.[Day] WHERE [Date] = @dt)
		BEGIN
			SELECT @dayId = Id FROM dbo.[Day] WHERE [Date] = @dt
		END
		ELSE
		BEGIN
			INSERT INTO dbo.[Day] ([Date]) VALUES (@dt)
			SET @dayId = SCOPE_IDENTITY()
		END

		-- Create a record in EmployeeDay table, if it does not already exist
		-- Ideally the record in EmployeeDay table should exist, but there could be
		-- error in tracking data capture
		INSERT INTO dbo.EmployeeDay
		(TenantEmployeeId, DayId, StartTime)
		SELECT Distinct o.EmployeeId, d.Id, CAST(o.ExpenseDate as [Date])
		FROM dbo.SqliteActionBatch o
		INNER JOIN dbo.[Day] d on d.[Date] = CAST(o.ExpenseDate as [DATE])
		AND o.Id = @batchId
		LEFT JOIN dbo.EmployeeDay ed on ed.TenantEmployeeId = o.EmployeeId
				  AND ed.DayId = d.Id
		WHERE ed.Id IS NULL

		-- Create expense Record
		DECLARE @expenseId BIGINT
		INSERT INTO dbo.Expense
		(EmployeeId, DayId, TotalAmount)
		OUTPUT inserted.EmployeeId, inserted.DayId, inserted.TotalAmount INTO @NewExpenses
		SELECT EmployeeId, @dayId, TotalExpenseAmount
		FROM dbo.SqliteActionBatch WHERE Id = @batchId
		SET @expenseId = SCOPE_IDENTITY()

		-- Now update the total amounts in EmployeeDay table
		UPDATE dbo.EmployeeDay 
		SET TotalExpenseAmount = TotalExpenseAmount + o.TotalAmount
		FROM dbo.EmployeeDay ed
		INNER JOIN 
			(SELECT employeeId, dayid, SUM(TotalAmount) TotalAmount FROM @NewExpenses GROUP BY employeeId, dayId) o 
		ON ed.TenantEmployeeId = o.EmployeeId AND ed.DayId = o.DayId

		-- Update batch record with expense Id
		UPDATE dbo.SqliteActionBatch
		SET ExpenseId = @expenseId,
		[Timestamp] = SYSUTCDATETIME()
		WHERE ID = @batchId

		-- Now create expense line items
		INSERT INTO dbo.ExpenseItem
		(ExpenseId, SequenceNumber, ExpenseType, TransportType, Amount, OdometerStart, OdometerEnd, ImageCount, FuelType, FuelQuantityInLiters, Comment)
		SELECT @expenseId, SequenceNumber, ExpenseType, VehicleType, Amount, OdometerStart, OdometerEnd, ImageCount, FuelType, FuelQuantityInLiters, Comment
		FROM dbo.SqliteExpense
		WHERE BatchId = @batchId

		-- Update ExpenseItemId in SqliteExpense
		UPDATE dbo.SqliteExpense
		SET ExpenseItemId = ei.Id,
		IsProcessed = 1,
		DateUpdated = SYSUTCDATETIME()
		FROM dbo.SqliteExpense sle
		INNER JOIN dbo.ExpenseItem ei on sle.SequenceNumber = ei.SequenceNumber
		AND sle.BatchId = @batchId
		AND ei.ExpenseId = @expenseId

		-- Now Images
		INSERT INTO dbo.[Image]
		(SourceId, [Data])  -- source id is used in next query listed below
		SELECT sei.id, sei.[Image]
		FROM dbo.SqliteExpenseImage sei
		INNER JOIN dbo.SqliteExpense se on sei.SqliteExpenseId = se.Id
		AND se.BatchId = @batchId
		
		-- Now create entries in ExpenseItemImage
		INSERT INTO dbo.ExpenseItemImage
		(ExpenseItemId, ImageId, SequenceNumber)
		SELECT ei.Id,i.[Id], sei.SequenceNumber
		FROM dbo.SqliteExpenseImage sei
		INNER JOIN dbo.[Image] i on sei.Id = i.SourceId
		INNER JOIN dbo.SqliteExpense sle on sei.SqliteExpenseId = sle.Id
		INNER JOIN dbo.ExpenseItem ei on sle.SequenceNumber = ei.SequenceNumber
		AND sle.BatchId = @batchId
		AND ei.ExpenseId = @expenseId
	END
END
GO
PRINT N'Altering [dbo].[ProcessSqliteOrderData]...';


GO
ALTER PROCEDURE [dbo].[ProcessSqliteOrderData]
	@batchId BIGINT
AS
BEGIN
	-- if batch is already processed - return	
	IF NOT EXISTS(SELECT 1 FROM dbo.SqliteActionBatch 
			WHERE Id = @batchId AND NumberOfOrdersSaved > 0
			AND BatchProcessed = 0)
	BEGIN
		RETURN;
	END

	DECLARE @NewOrders TABLE
	(EmployeeId BIGINT,
	 DayId BIGINT,
	 TotalAmount DECIMAL(19,2)
	)
	
	-- to aid in processing, we have added a column SqliteOrderId in dbo.Order table;

	-- First create required records in Day Table
	INSERT INTO dbo.[Day]
	([DATE])
	SELECT DISTINCT CAST(o.OrderDate AS [Date])
	FROM dbo.SqliteOrder o
	LEFT JOIN dbo.[Day] d on CAST(o.OrderDate AS [Date]) = d.[DATE]
	WHERE o.BatchId = @batchId
	AND d.[DATE] IS NULL

	-- Create records in EmployeeDay table if it not already exist.
	INSERT INTO dbo.EmployeeDay
	(TenantEmployeeId, DayId, StartTime)
	SELECT Distinct o.EmployeeId, d.Id, CAST(o.OrderDate as [Date])
	FROM dbo.SqliteOrder o
	INNER JOIN dbo.[Day] d on d.[Date] = CAST(o.OrderDate as [DATE])
	AND o.BatchId = @batchId
	LEFT JOIN dbo.EmployeeDay ed on ed.TenantEmployeeId = o.EmployeeId
	          AND ed.DayId = d.Id
	WHERE ed.Id IS NULL

	-- Now create records in dbo.Order Table
	-- (At the time of processing batches, set RevisedTotalAmount to TotalAmount)
	INSERT INTO dbo.[Order]
	(EmployeeId, DayId, CustomerCode, OrderType, OrderDate, TotalAmount, ItemCount, SqliteOrderId, RevisedTotalAmount)
	OUTPUT inserted.EmployeeId, inserted.DayId, inserted.TotalAmount INTO @NewOrders
	SELECT EmployeeId, d.Id, CustomerCode, o.OrderType, CAST(o.OrderDate as [DATE]), o.TotalAmount, o.ItemCount, o.Id, o.TotalAmount
	FROM dbo.SqliteOrder o
	INNER JOIN dbo.[Day] d ON d.[DATE] = CAST(o.OrderDate AS [Date])
	WHERE BatchId = @batchId
	ORDER BY o.Id

	-- Now update the total amounts in EmployeeDay table
	UPDATE dbo.EmployeeDay 
	SET TotalOrderAmount = TotalOrderAmount + o.TotalAmount
	FROM dbo.EmployeeDay ed
	INNER JOIN 
	     (SELECT employeeId, dayid, SUM(TotalAmount) TotalAmount FROM @NewOrders GROUP BY employeeId, dayId) o 
	ON ed.TenantEmployeeId = o.EmployeeId AND ed.DayId = o.DayId

	-- now we need to copy line items
	-- (Similarly at the time of batch processes, set Revised Unit Quantity and RevisedAmount to UnitQuantity and Amount)
	INSERT INTO dbo.OrderItem
	(OrderId, SerialNumber, ProductCode, UnitQuantity, UnitPrice, Amount, RevisedUnitQuantity, RevisedAmount)
	SELECT o.Id, soi.SerialNumber, soi.ProductCode, soi.UnitQuantity, soi.UnitPrice, soi.Amount, soi.UnitQuantity, soi.Amount
	FROM dbo.SqliteOrderItem soi
	INNER JOIN dbo.SqliteOrder so on soi.SqliteOrderId = so.Id
	AND so.BatchId = @batchId
	INNER JOIN dbo.[Order] o on so.Id = o.SqliteOrderId

	-- now we need to update the orderId back in SqliteOrder table
	UPDATE dbo.SqliteOrder
	SET OrderId = o.Id,
	IsProcessed = 1,
	DateUpdated = SYSUTCDATETIME()
	FROM dbo.SqliteOrder so
	INNER JOIN dbo.[Order] o on so.Id = o.SqliteOrderId
	AND so.BatchId = @batchId
END
GO
PRINT N'Altering [dbo].[ProcessSqlitePaymentData]...';


GO
ALTER PROCEDURE [dbo].[ProcessSqlitePaymentData]
	@batchId BIGINT
AS
BEGIN

	-- if batch is already processed - return	
	IF NOT EXISTS(SELECT 1 FROM dbo.SqliteActionBatch 
			WHERE Id = @batchId AND NumberOfPaymentsSaved > 0
			AND BatchProcessed = 0)
	BEGIN
		RETURN;
	END

	DECLARE @NewPayments TABLE
	(EmployeeId BIGINT,
	 DayId BIGINT,
	 TotalAmount DECIMAL(19,2)
	)

	-- First create required records in Day Table
	INSERT INTO dbo.[Day]
	([DATE])
	SELECT DISTINCT CAST(p.PaymentDate AS [Date])
	FROM dbo.SqlitePayment p
	LEFT JOIN dbo.[Day] d on CAST(p.PaymentDate AS [Date]) = d.[DATE]
	WHERE p.BatchId = @batchId
	AND d.[DATE] IS NULL

	-- Create records in EmployeeDay table if it not already exist.
	INSERT INTO dbo.EmployeeDay
	(TenantEmployeeId, DayId, StartTime)
	SELECT Distinct o.EmployeeId, d.Id, CAST(o.PaymentDate as [Date])
	FROM dbo.SqlitePayment o
	INNER JOIN dbo.[Day] d on d.[Date] = CAST(o.PaymentDate as [DATE])
	AND o.BatchId = @batchId
	LEFT JOIN dbo.EmployeeDay ed on ed.TenantEmployeeId = o.EmployeeId
	          AND ed.DayId = d.Id
	WHERE ed.Id IS NULL

	-- Create Payment Records
	INSERT INTO dbo.[Payment]
	(EmployeeId, DayId, CustomerCode, PaymentType, PaymentDate, TotalAmount, Comment, ImageCount, SqlitePaymentId)
	OUTPUT inserted.EmployeeId, inserted.DayId, inserted.TotalAmount INTO @NewPayments
	SELECT EmployeeId, d.Id, CustomerCode, p.PaymentType, CAST(p.PaymentDate as [DATE]), p.TotalAmount, p.Comment, p.ImageCount, p.Id
	FROM dbo.SqlitePayment p
	INNER JOIN dbo.[Day] d ON d.[DATE] = CAST(p.PaymentDate AS [Date])
	WHERE BatchId = @batchId
	ORDER BY p.Id

	-- Now update the total amounts in EmployeeDay table
	UPDATE dbo.EmployeeDay 
	SET TotalPaymentAmount = TotalPaymentAmount + o.TotalAmount
	FROM dbo.EmployeeDay ed
	INNER JOIN 
	     (SELECT employeeId, dayid, SUM(TotalAmount) TotalAmount FROM @NewPayments GROUP BY employeeId, dayId) o 
	 ON ed.TenantEmployeeId = o.EmployeeId AND ed.DayId = o.DayId

	-- now we need to update the Payment back in SqlitePayment table
	UPDATE dbo.SqlitePayment
	SET PaymentId = p.Id,
	IsProcessed = 1,
	DateUpdated = SYSUTCDATETIME()
	FROM dbo.SqlitePayment sp
	INNER JOIN dbo.[Payment] p on sp.Id = p.SqlitePaymentId
	AND sp.BatchId = @batchId

	-- Now Images
	INSERT INTO dbo.[Image]
	(SourceId, PaymentSourceId, [Data])  -- Payment source id is used in next query listed below
	SELECT 0, spi.id, spi.[Image]
	FROM dbo.SqlitePaymentImage spi
	INNER JOIN dbo.SqlitePayment sp on spi.SqlitePaymentId = sp.Id
	AND sp.BatchId = @batchId
		
	-- Now create entries in PaymentImage
	INSERT INTO dbo.PaymentImage
	(PaymentId, ImageId, SequenceNumber)
	SELECT p.Id, i.[Id], spi.SequenceNumber
	FROM dbo.SqlitePaymentImage spi
	INNER JOIN dbo.[Image] i on spi.Id = i.PaymentSourceId
	INNER JOIN dbo.SqlitePayment slp on spi.SqlitePaymentId = slp.Id
	AND slp.BatchId = @batchId
	INNER JOIN dbo.Payment p on slp.Id = p.SqlitePaymentId
END
GO
PRINT N'Altering [dbo].[ProcessSqliteReturnOrderData]...';


GO
ALTER PROCEDURE [dbo].[ProcessSqliteReturnOrderData]
	@batchId BIGINT
AS
BEGIN
	-- if batch is already processed - return	
	IF NOT EXISTS(SELECT 1 FROM dbo.SqliteActionBatch 
			WHERE Id = @batchId AND NumberOfReturnsSaved > 0
			AND BatchProcessed = 0)
	BEGIN
		RETURN;
	END

	DECLARE @NewReturnOrders TABLE
	(EmployeeId BIGINT,
	 DayId BIGINT,
	 TotalAmount DECIMAL(19,2)
	)

	-- to aid in processing, we have added a column SqliteReturnOrderId in dbo.ReturnOrder table;

	-- First create required records in Day Table
	INSERT INTO dbo.[Day]
	([DATE])
	SELECT DISTINCT CAST(o.ReturnOrderDate AS [Date])
	FROM dbo.SqliteReturnOrder o
	LEFT JOIN dbo.[Day] d on CAST(o.ReturnOrderDate AS [Date]) = d.[DATE]
	WHERE o.BatchId = @batchId
	AND d.[DATE] IS NULL

	-- Create records in EmployeeDay table if it not already exist.
	INSERT INTO dbo.EmployeeDay
	(TenantEmployeeId, DayId, StartTime)
	SELECT Distinct o.EmployeeId, d.Id, CAST(o.ReturnOrderDate as [Date])
	FROM dbo.SqliteReturnOrder o
	INNER JOIN dbo.[Day] d on d.[Date] = CAST(o.ReturnOrderDate as [DATE])
	AND o.BatchId = @batchId
	LEFT JOIN dbo.EmployeeDay ed on ed.TenantEmployeeId = o.EmployeeId
	          AND ed.DayId = d.Id
	WHERE ed.Id IS NULL

	-- Now create records in dbo.ReturnOrder Table
	INSERT INTO dbo.[ReturnOrder]
	(EmployeeId, DayId, CustomerCode, ReturnOrderDate, TotalAmount, ItemCount, SqliteReturnOrderId, ReferenceNumber, Comment)
	OUTPUT inserted.EmployeeId, inserted.DayId, inserted.TotalAmount INTO @NewReturnOrders
	SELECT EmployeeId, d.Id, CustomerCode, CAST(o.ReturnOrderDate as [DATE]), o.TotalAmount, o.ItemCount, o.Id, o.ReferenceNum, o.Comment
	FROM dbo.SqliteReturnOrder o
	INNER JOIN dbo.[Day] d ON d.[DATE] = CAST(o.ReturnOrderDate AS [Date])
	WHERE BatchId = @batchId
	ORDER BY o.Id

	-- Now update the total amounts in EmployeeDay table
	UPDATE dbo.EmployeeDay 
	SET TotalReturnAmount = TotalReturnAmount + o.TotalAmount
	FROM dbo.EmployeeDay ed
	INNER JOIN 
		(SELECT employeeId, dayid, SUM(TotalAmount) TotalAmount FROM @NewReturnOrders GROUP BY employeeId, dayId) o 
	ON ed.TenantEmployeeId = o.EmployeeId AND ed.DayId = o.DayId

	-- now we need to copy line items
	INSERT INTO dbo.ReturnOrderItem
	(ReturnOrderId, SerialNumber, ProductCode, UnitQuantity, UnitPrice, Amount, Comment)
	SELECT o.Id, soi.SerialNumber, soi.ProductCode, soi.UnitQuantity, soi.UnitPrice, soi.Amount, soi.Comment
	FROM dbo.SqliteReturnOrderItem soi
	INNER JOIN dbo.SqliteReturnOrder so on soi.SqliteReturnOrderId = so.Id
	AND so.BatchId = @batchId
	INNER JOIN dbo.[ReturnOrder] o on so.Id = o.SqliteReturnOrderId

	-- now we need to update the ReturnOrderId back in SqliteReturnOrder table
	UPDATE dbo.SqliteReturnOrder
	SET ReturnOrderId = o.Id,
	IsProcessed = 1,
	DateUpdated = SYSUTCDATETIME()
	FROM dbo.SqliteReturnOrder so
	INNER JOIN dbo.[ReturnOrder] o on so.Id = o.SqliteReturnOrderId
	AND so.BatchId = @batchId
END
GO
PRINT N'Altering [dbo].[StartEmployeeDay]...';


GO
ALTER PROCEDURE [dbo].[StartEmployeeDay]
	@employeeId BIGINT,
	@startDateTime DateTime2,

    @PhoneModel NVARCHAR(100),
    @PhoneOS NVARCHAR(10),
    @AppVersion NVARCHAR(10),

	@employeeDayId BIGINT OUTPUT
AS
BEGIN
   -- Records start of the day activity
   -- First Selet DayId from dbo.Day table for start date time
   DECLARE @dayId BIGINT
   DECLARE @startDate DATE = CAST(@startDateTime AS [Date])

	IF EXISTS(SELECT 1 FROM dbo.[Day] WHERE [Date] = @startDate)
	BEGIN
		SELECT @dayId = Id FROM dbo.[Day] WHERE [Date] = @startDate
	END
	ELSE
	BEGIN
		INSERT INTO dbo.[Day] ([Date]) VALUES (@startDate)
		SET @dayId = SCOPE_IDENTITY()
	END

	SET @employeeDayId = 0

	-- check if a record already exist in Employee Day table.
	IF EXISTS(SELECT 1 FROM dbo.EmployeeDay WHERE TenantEmployeeId=@employeeId AND DayId = @dayId)
	BEGIN
		SELECT @employeeDayId=Id FROM dbo.EmployeeDay WHERE TenantEmployeeId=@employeeId AND DayId = @dayId
		UPDATE dbo.EmployeeDay 
		SET EndTime = Null, TotalDistanceInMeters = 0,
		    HasMultipleStarts = 1
		WHERE Id = @employeeDayId 
	END

	ELSE

	BEGIN
		-- pick up HQ Code from SalesPerson table
		DECLARE @hqCode VARCHAR(10)
		DECLARE @areaCode VARCHAR(10)

		-- Copy the hq code and area code in Employee Day table
		-- as later sales Person's HQ Code can change
		-- And For reporting purposes, we should be using the HQ Code
		-- that the person had on the date he worked.
		SELECT Top(1) @hqCode = ISNULL(oh.HQCode,''), @areaCode = ISNULL(oh.AreaCode, '')
		FROM dbo.TenantEmployee te 
		INNER JOIN dbo.SalesPerson sp on te.EmployeeCode = sp.StaffCode
		AND te.Id = @employeeId
		INNER JOIN dbo.OfficeHierarchy oh on sp.HQCode = oh.HQCode
		AND oh.IsActive = 1

		INSERT INTO dbo.EmployeeDay
		(TenantEmployeeId, DayId, StartTime, HQCode, AreaCode, PhoneModel, PhoneOS, AppVersion)
		VALUES
		(@employeeId, @dayId, @startDateTime, ISNULL(@hqCode, ''), ISNULL(@areaCode, ''),
			@PhoneModel, @PhoneOS, @AppVersion)

		SET @employeeDayId = SCOPE_IDENTITY()
	END
END
GO
PRINT N'Altering [dbo].[GetInFieldSalesPeople]...';


GO
ALTER PROCEDURE [dbo].[GetInFieldSalesPeople]
		@inputDate DateTime2
AS
BEGIN

	DECLARE @SignedInEmployeeData TABLE
	(
        EmployeeDayId BIGINT,
		EmployeeId BIGINT,
		StartTime DATETIME2,
		EndTime DATETIME2,
		TotalOrderAmount DECIMAL(19,2),
		TotalPaymentAmount DECIMAL(19,2),
		TotalReturnAmount DECIMAL(19,2),
		TotalExpenseAmount DECIMAL(19,2),
		Latitude DECIMAL(19,9),
		Longitude DECIMAL(19,9),
		PhoneModel NVARCHAR(100),
		PhoneOS NVARCHAR(10),
		AppVersion NVARCHAR(10)
	)

	INSERT INTO @SignedInEmployeeData
	(EmployeeDayId, EmployeeId, StartTime, EndTime, 
	 TotalOrderAmount, TotalPaymentAmount, TotalReturnAmount, TotalExpenseAmount,
	 Latitude, Longitude, PhoneModel, PhoneOS, AppVersion
	)
	SELECT ed.Id, ed.TenantEmployeeId, StartTime, EndTime, 
	TotalOrderAmount, TotalPaymentAmount, 
	TotalReturnAmount, TotalExpenseAmount,
	CurrentLatitude, CurrentLongitude,
	PhoneModel, PhoneOS, AppVersion
	FROM dbo.[Day] d
	INNER JOIN dbo.EmployeeDay ed on d.Id = ed.DayId
	AND d.[DATE] = CAST(@inputDate AS [Date])
	
	-- RESULT SET QUERY
	;WITH cteAreaCodes(AreaCode)
	AS
	( 
		SELECT Distinct  AreaCode FROM dbo.OfficeHierarchy 
		WHERE IsActive = 1
	)
	SELECT ISNULL(cte.AreaCode, '***') AreaCode, 
	ISNULL(sq.StaffCode, '') StaffCode, 
	ISNULL(sq.IsInFieldToday, 0) IsInFieldToday,
	ISNULL(sq.IsRegisteredOnPhone,0) IsRegisteredOnPhone,
	sq.StartTime,
	sq.EndTime,
	ISNULL(sq.TotalOrderAmount, 0) as TotalOrderAmount,
	ISNULL(sq.TotalPaymentAmount,0) as TotalPaymentAmount,
	ISNULL(sq.TotalReturnAmount,0) as TotalReturnAmount,
	ISNULL(sq.TotalExpenseAmount,0) as TotalExpenseAmount,
	ISNULL(sq.Latitude,0) as Latitude,
	ISNULL(sq.Longitude,0) as Longitude,
	ISNULL(sq.PhoneModel, '') AS PhoneModel,
	ISNULL(sq.PhoneOS, '') AS PhoneOS,
	ISNULL(sq.AppVersion, '') AS AppVersion

	FROM cteAreaCodes cte
	FULL OUTER JOIN 
			(
				-- Employee Code and Area Codes, IsInFieldToday, IsRegisteredOnPhone
				SELECT sp.StaffCode, 
				ISNULL(oh.AreaCode, '***') AreaCode, 
				CASE WHEN ed.EmployeeId IS NULL THEN 0 ELSE 1 END IsInFieldToday,
				CASE WHEN te.Id IS NULL THEN 0 ELSE 1 END IsRegisteredOnPhone,

				ed.StartTime,
				ed.EndTime,
				ed.TotalOrderAmount,
				ed.TotalPaymentAmount,
				ed.TotalReturnAmount,
				ed.TotalExpenseAmount,
				ed.Latitude,
				ed.Longitude,
				ed.PhoneModel,
				ed.PhoneOS,
				ed.AppVersion

				FROM dbo.SalesPerson sp
				LEFT join dbo.OfficeHierarchy oh on sp.HQCode = oh.HQCode and oh.IsActive = 1
				LEFT JOIN dbo.TenantEmployee te on te.EmployeeCode = sp.StaffCode and te.IsActive = 1
				LEFT JOIN @SignedInEmployeeData ed on te.Id = ed.EmployeeId
				WHERE sp.IsActive = 1
			) sq ON cte.AreaCode = sq.AreaCode

  -- Cases covered
  -- 1. SalesPerson table may have a HQ code that does not exist in Office hierarchy
  --    We still want such a record in the resultset with Areacode as '***'
END
GO
PRINT N'Refreshing [dbo].[AddActivityData]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[AddActivityData]';


GO
PRINT N'Refreshing [dbo].[ClearEmployeeData]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[ClearEmployeeData]';


GO
PRINT N'Refreshing [dbo].[EndEmployeeDay]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[EndEmployeeDay]';


GO
PRINT N'Refreshing [dbo].[GetSignedInEmployeeData]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[GetSignedInEmployeeData]';


GO
PRINT N'Refreshing [dbo].[sp_DashboardData]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[sp_DashboardData]';


GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------

DELETE FROM dbo.EmployeeDay;
DELETE FROM dbo.TenantEmployee;
DELETE FROM dbo.Tenant;
DELETE FROM dbo.[Day]
GO

INSERT INTO dbo.Tenant
(Name, [Description])
values
('Poonalab', 'Poonalab')
go

DECLARE @tenantId BIGINT
SELECT @tenantId = Id from dbo.Tenant where Name='Poonalab'

INSERT INTO dbo.TenantEmployee
(TenantId, Name)
VALUES
(@tenantId, 'Guru'),
(@tenantId, 'NagaArjun')
go

--DECLARE @appStartDay SmallDATETIME = SysUtcDateTime()
--DECLARE @i int = 1

--WHILE @i < (365*3)
--BEGIN
--   INSERT INTO dbo.[Day]
--   ([Date])
--   Values
--   (DATEADD(Day, @i, @appStartDay))

--   SET @i = @i + 1
--END
GO
*/
GO

GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
CREATE TABLE [#__checkStatus] (
    id           INT            IDENTITY (1, 1) PRIMARY KEY CLUSTERED,
    [Schema]     NVARCHAR (256),
    [Table]      NVARCHAR (256),
    [Constraint] NVARCHAR (256)
);

SET NOCOUNT ON;

DECLARE tableconstraintnames CURSOR LOCAL FORWARD_ONLY
    FOR SELECT SCHEMA_NAME([schema_id]),
               OBJECT_NAME([parent_object_id]),
               [name],
               0
        FROM   [sys].[objects]
        WHERE  [parent_object_id] IN (OBJECT_ID(N'dbo.Order'), OBJECT_ID(N'dbo.OrderItem'), OBJECT_ID(N'dbo.SqliteActionImage'), OBJECT_ID(N'dbo.SqliteAction'))
               AND [type] IN (N'F', N'C')
                   AND [object_id] IN (SELECT [object_id]
                                       FROM   [sys].[check_constraints]
                                       WHERE  [is_not_trusted] <> 0
                                              AND [is_disabled] = 0
                                       UNION
                                       SELECT [object_id]
                                       FROM   [sys].[foreign_keys]
                                       WHERE  [is_not_trusted] <> 0
                                              AND [is_disabled] = 0);

DECLARE @schemaname AS NVARCHAR (256);

DECLARE @tablename AS NVARCHAR (256);

DECLARE @checkname AS NVARCHAR (256);

DECLARE @is_not_trusted AS INT;

DECLARE @statement AS NVARCHAR (1024);

BEGIN TRY
    OPEN tableconstraintnames;
    FETCH tableconstraintnames INTO @schemaname, @tablename, @checkname, @is_not_trusted;
    WHILE @@fetch_status = 0
        BEGIN
            PRINT N'Checking constraint: ' + @checkname + N' [' + @schemaname + N'].[' + @tablename + N']';
            SET @statement = N'ALTER TABLE [' + @schemaname + N'].[' + @tablename + N'] WITH ' + CASE @is_not_trusted WHEN 0 THEN N'CHECK' ELSE N'NOCHECK' END + N' CHECK CONSTRAINT [' + @checkname + N']';
            BEGIN TRY
                EXECUTE [sp_executesql] @statement;
            END TRY
            BEGIN CATCH
                INSERT  [#__checkStatus] ([Schema], [Table], [Constraint])
                VALUES                  (@schemaname, @tablename, @checkname);
            END CATCH
            FETCH tableconstraintnames INTO @schemaname, @tablename, @checkname, @is_not_trusted;
        END
END TRY
BEGIN CATCH
    PRINT ERROR_MESSAGE();
END CATCH

IF CURSOR_STATUS(N'LOCAL', N'tableconstraintnames') >= 0
    CLOSE tableconstraintnames;

IF CURSOR_STATUS(N'LOCAL', N'tableconstraintnames') = -1
    DEALLOCATE tableconstraintnames;

SELECT N'Constraint verification failed:' + [Schema] + N'.' + [Table] + N',' + [Constraint]
FROM   [#__checkStatus];

IF @@ROWCOUNT > 0
    BEGIN
        DROP TABLE [#__checkStatus];
        RAISERROR (N'An error occurred while verifying constraints', 16, 127);
    END

SET NOCOUNT OFF;

DROP TABLE [#__checkStatus];


GO
PRINT N'Update complete.';


GO

update dbo.[order] set revisedTotalAmount = totalAmount
go

update dbo.OrderItem set RevisedUnitQuantity = UnitQuantity,RevisedAmount = Amount
go

insert into dbo.CodeTable
(Codetype, Codevalue, DisplaySequence, IsActive)
values
('CustomerType', 'Society', 40, 1),
('ExpenseType', 'DA (Outstation)', 12, 1)
go

update dbo.CodeTable set CodeValue = 'DA (Local)' where CodeValue = 'Daily Allowance' and CodeType='ExpenseType'
go




insert into dbo.appVersion
([Version], EffectiveDate, ExpiryDate)
values
('1.3', '2017-11-26', '2099-12-31'),
('legacy', '2017-01-01', '2099-12-31')
